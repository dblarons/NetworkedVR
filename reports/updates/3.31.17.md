# 3.30.17

## Summary

I significantly cleaned up the one-way synchronization code in order to make it easier
to add two-way syncing. Specifically, I pushed serialization logic closer to the objects
that are being serialized and out of bloated utils classes. I also expanded the `NetworkedObject`
component, which can be attached to any object in a game in order to sync it.

Then, I changed how state is buffered internally from world level to object level.
This is required now that objects don't send updates every frame if they aren't moving.

Here is how state was previously buffered (n is most recent):

```
[n] world state: obj1, obj2, obj3
[n-1] world state: obj1, obj2, obj3
[n-2] world state: obj1, obj2, obj3
```

And here is how it is buffered now:

```
[n] obj1
[n-1] obj1
No n-2 value since obj1 was created at time n-1

[n] obj1
[n-1] obj2
[n-2] obj3

etc.
```

I moved my weekly update emails into markdown files under the [updates](../updates) directory 
(I accidently put this weekly update under `weekly-updates`... will fix that). The weekly updates
include links to my videos.

I did not have time to convert my pdf reports into markdown and will do that for next week.

Finally, I spent the end of the week working on "reverse syncing" from peers that own secondary objects
to peers that own the primaries for those secondaries. I wrote some code for this, and have a plan (described 
below) for the remainder of the work.

I did not have time to start on the Python ledger research.

If I were to extend this library to work with multiple peers, I would do the following:

- Each peer would have one `NetServer` instance which sends out updates to its primary objects.
  Many peers can connect to that single `NetServer` instance.
  
- Each peer would have many `NetClient` instances, each of which correspond to one or more secondary
  objects and communicate with one peer each.
  
- In summary, each peer would have one `NetServer` instance and n `NetClient` instances where n is
 Â the number of other players in the game.
  
## Saturday, 3/25

Cleaned up one-way synchronization PR: https://github.com/dblarons/NetworkedVR/pull/11

## Sunday, 3/26

Finished cleaning up one-way synchronization PR and merged my code: https://github.com/dblarons/NetworkedVR/pull/11

## Wednesday, 3/28

- Move all weekly updates and papers (still in pdf format) into repo

- TODO: Convert papers to markdown

## Thursday, 3/29

- Refactor to only send updates from objects when they have moved

- diff: https://github.com/dblarons/NetworkedVR/compare/delta-encoding?expand=1

## Friday, 3/31

- Refactor to buffer updates on a per-object basis, rather than on a universal basis (same diff as above)

- Spent time thinking about how updates for secondary objects can be distinguished from interpolation as a result of existing primary updates

  - Ball rolling case: Updates from a secondary to a primary for a ball that is rolling will look "behind"
    to the primary; there is potential that it gets confused and reverses the ball's direction

  - Ping pong case: If ball is on primary, when secondary hits ball it does not interact with the ball
    directly, but rather uses an intermediary object to interact with the ball

    - Therefore, cannot set a flag on an object to signify that it is being interacted with

  - Best option is to tag and keep a backlog of updates on the primary; secondary will send the two tags it is
    interpolating between and t value along with its update to the primary; primary will compare the secondary's 
    update position with the interpolated value, and if it is different, update itself
    
    - In the literature: state resolution

  - Still unknown: When secondary interacts with object, object will still be getting interpolated over by the 
    primary

    - Possible solution: Check secondary position with expected interpolated position before applying the new
      interpolated position; if expected position does not equal matched position, "free" the object from
      interpolation for this time interval
